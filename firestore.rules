/**
 * Firestore Security Rules for On-Campus Nutrition Tracker
 * 
 * Purpose: Server-side validation and authorization enforcement
 * Security Principles:
 * - Defense in Depth: Mirrors client-side validation for DoS protection
 * - Principle of Least Privilege: Users can only access their own data
 * - Authorization Gates: All writes require user authentication and ownership check
 * 
 * DRY (Don't Repeat Yourself): Validation constraints defined once:
 * - MAX_NAME_LENGTH = 100 characters (meal name, serving size)
 * - MAX_TEXT_LENGTH = 300 characters (notes/other info)
 * - MAX_CALORIES = 5000 per serving
 * - MAX_MACRO = 2000 grams (carbs, fat, protein)
 * 
 * These match src/utils/mealValidation.ts MEAL_CONSTRAINTS for consistency
 */

rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper function: Check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }
    
    // Helper function: Check if user owns the resource
    function isOwner(userId) {
      return request.auth.uid == userId;
    }
    
    // Helper function: Validate meal data structure and constraints
    // Returns true if all validation checks pass
    function isValidMeal(data) {
      // Required fields presence check
      return data.keys().hasAll(['name', 'servingSize', 'calories', 'userId', 'createdAt'])
        // Name validation: Required, max 100 chars (prevent DoS via oversized strings)
        && data.name is string
        && data.name.size() > 0
        && data.name.size() <= 100
        // Serving size validation: Required, max 100 chars
        && data.servingSize is string
        && data.servingSize.size() > 0
        && data.servingSize.size() <= 100
        // Calories validation: Required numeric, 0-5000 range (realistic bounds)
        && data.calories is number
        && data.calories >= 0
        && data.calories <= 5000
        // User ID validation: Must be string
        && data.userId is string
        && data.userId.size() > 0
        // Created timestamp validation: Must be numeric (milliseconds since epoch)
        && (data.createdAt is number || data.createdAt is timestamp)
        // Optional numeric fields: If present, must be valid numbers within realistic bounds
        && (!('servingsHad' in data) || (data.servingsHad is number && data.servingsHad >= 0))
        && (!('totalCarbs' in data) || (data.totalCarbs is number && data.totalCarbs >= 0 && data.totalCarbs <= 2000))
        && (!('totalFat' in data) || (data.totalFat is number && data.totalFat >= 0 && data.totalFat <= 2000))
        && (!('protein' in data) || (data.protein is number && data.protein >= 0 && data.protein <= 2000))
        && (!('sodium' in data) || (data.sodium is number && data.sodium >= 0))
        && (!('sugars' in data) || (data.sugars is number && data.sugars >= 0))
        && (!('calcium' in data) || (data.calcium is number && data.calcium >= 0))
        && (!('iron' in data) || (data.iron is number && data.iron >= 0))
        // Optional string fields: If present, must be valid strings within length limits
        && (!('fatCategories' in data) || (data.fatCategories is string && data.fatCategories.size() <= 100))
        && (!('vitamins' in data) || (data.vitamins is string && data.vitamins.size() <= 300))
        && (!('otherInfo' in data) || (data.otherInfo is string && data.otherInfo.size() <= 300));
    }
    
    // User documents: Store user preferences, meal history, favorites
    match /users/{userId} {
      // Users can only read/write their own document
      allow read, write: if isAuthenticated() && isOwner(userId);
      
      // Subcollections: All user data is private to the user
      match /{document=**} {
        allow read, write: if isAuthenticated() && isOwner(userId);
      }
    }
    
    // Meals collection: Track user meal entries with nutrition data
    match /meals/{mealId} {
      // Read: Users can only read meals they own (privacy)
      allow read: if isAuthenticated() && isOwner(resource.data.userId);
      
      // Create: Authenticated users can create meals if they set userId to their own ID
      // Prevents spoofing (user cannot create meals for another user)
      allow create: if isAuthenticated()
        && request.auth.uid == request.resource.data.userId
        && isValidMeal(request.resource.data);
      
      // Update: Users can only update meals they own
      // Validates all fields match constraints
      allow update: if isAuthenticated()
        && isOwner(resource.data.userId)
        && isValidMeal(request.resource.data);
      
      // Delete: Users can only delete meals they own
      allow delete: if isAuthenticated()
        && isOwner(resource.data.userId);
    }
    
    // Favorites collection: Store user's favorite meals for quick access
    match /favorites/{favoriteId} {
      // Read: Users can only access their own favorites
      allow read: if isAuthenticated() && isOwner(resource.data.userId);
      
      // Create: Authenticated users can add to their favorites
      allow create: if isAuthenticated()
        && request.auth.uid == request.resource.data.userId;
      
      // Update: Users can only update their own favorites
      allow update: if isAuthenticated()
        && isOwner(resource.data.userId);
      
      // Delete: Users can only delete their own favorites
      allow delete: if isAuthenticated()
        && isOwner(resource.data.userId);
    }
    
    // Deny all other access by default (secure by default)
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
